I was working on a project related to  in which  we were supposed to  design , verify and implement the chip and send it for tapeout , it was in collaboration woth synopsys and global foundry 

so  i have got the mail from the mentor to prepare a report about what we ahve done and learnt throughtout these 5 months 

this was the mail i got 
Many congratulations on the tapeout of the SIDHARUD1 chip. There has been a lot of effort from everyone of you in making the task possible.

Moving forward, as you have expressed interest to earn credit for the effort, you are requested to furnish a detailed report on the work you carried out in the SIDHARUD project (emphasizing the task/spec, proposed method, analysis, code/script, outcomes, contribution etc...) at individual level. Your work shall be reviewed and asked to present in front of a review panel.

As part of the project/activity evaluation process, the assessment panel will review each submission based on the following criteria:

Relevance of the activity to the student’s academic program or learning objectives.

Quality and completeness of the documentation submitted (e.g., certificates, reports, project outcomes).

Outcomes achieved, including skills developed, problem-solving ability, or innovation demonstrated.

Presentation or viva, to assess understanding and engagement.

Note: Based on the panel’s recommendations, appropriate credits and grades will be awarded to the students.




so now i will tell about the project and what was my contribution in it 


so the project was to make a chip which can be implemented in multiple  mode  so i will tell you details about the modes 


Mode-1 (QSPI, I2C-M, I2C-S, UART)		Mode-2 (Port Extender) 		Mode-3 (SDIO, 2x I2C-M, I2C-S, 2x UART)		Mode-4 (QSPI, I2C-M, I2C-S, UART)	
"JTAGEN=1 (default)  <- JTAG interface is selected. 
If this is explicitly made 0 , then the pins become FGPIO"		"JTAGEN=1 (default)  <- JTAG interface is selected. 
If this is explicitly made 0 , then the pins become FGPIO"		"JTAGEN=1 (default)  <- JTAG interface is selected. 
If this is explicitly made 0 , then the pins become FGPIO"		"JTAGEN=1 (default)  <- JTAG interface is selected. 
If this is explicitly made 0 , then the pins become FGPIO"	




but due to area constraints we went  were only able to implement mode 1 

with the following pins 

PAD Function	PAD Configuration
	
CLK	IN
RST_N	IN
TCK / FGPIO_IN_10	IN
TRST  / FGPIO_IN_11	IN
TMS  / FGPIO_IN_12	IN
TDI  / FGPIO_IN_13	IN
BOOT_MODE_SEL	IN
FGPIO_IN_0	IN
FGPIO_IN_1	IN
FGPIO_IN_2	IN
FGPIO_IN_3	IN
FGPIO_IN_4	IN
I2C_S_SCL_I 	IN
FGPIO_IN_5	IN
FGPIO_IN_6	IN
FGPIO_IN_7	IN
FGPIO_IN_8	IN
FGPIO_IN_9	IN
	
	
TDO/ FGPIO_OUT_13	OUT
FGPIO_OUT_0	OUT
FGPIO_OUT_1	OUT
FGPIO_OUT_2	OUT
FGPIO_OUT_3	OUT
FGPIO_OUT_4	OUT
FGPIO_OUT_5	OUT
FGPIO_OUT_6	OUT
FGPIO_OUT_7	OUT
FGPIO_OUT_8	OUT
FGPIO_OUT_9	OUT
I2C_S_SDA	BI
FGPIO_OUT_10	OUT
FGPIO_OUT_11	OUT
FGPIO_OUT_12	OUT

i was mainly in verification team  , but due to this i had to understand the design also  and once the  verification work was done i shifted to boot loader development work and then physical design work 

in verification 


Maintaining the
MoM and All the
Verification
related
documentation

Updated the
Make file for the
SPI Flash 

added temporary
testbenches for
spiflash method
that will be
merged to the
top testbench

Added Makefile
commands for
running verdi

spiflash.v made
to implements
only flash
method

spiflash.v made
to implements
only flash
method

Restructured
the MakeFile for
running our
commands

All the reports
and the files are
there in the
drive 

Boot Rom
Testing Started

Made a separate
testbench for
testing bootrom

modified
testbench for
debugging the
verification
issues of the
booting

Verified the
bootrom getting
valid results

spiflash.v made
to implements
only flash
method

made changes in
the respective
files

And then came
to know that it
was not
supposed to be
verified as
separately

Made Changes in
the MakeFile to
test the
bootrom

corrected
the
relative
file path
for the
verified
boot

Shifted to
Physical Design
and Verification
Team

Netlist
Verification

Started to
implement the pd
flow 

Also Used
formality 

Cross checking
the cells and
blocks of the
netlist from the
pdk

Started to help
in works related
to PD and
Design team

implemented
different
versions of it
and report back
the errors or
warnings with
reason for the
problem

rtl and netlist
were compared
here in order to
see it both are
same of not

made top tb for
checking clk connections
and modified MakeFile
to compile and simulate
top_tb

I2C for mode2
(port_extender) has
been verified
successfully and adding
a
firmware_for_verificatio
n.txt file that contains
all the assembly codes
required

issues of not getting
signals from some pins
has been resolved

removed all the
warnings
encountered
during the
compilation of
the rtl with tb

reset, intial
write and read
verified for
memory

replaced the existing
mem_init_files folder
with the new one
and named the old
one as
mem_init_files_old

Also did GPIO
Verification Once
when the design
was modified

modified makefile to
remove errors

testing signals
by giving
different bit
patterns

Released the
Verification Tag 

State to work
on Bootloader
(Firmaware) 

removed the
glitches occuring
during random
read

Made Changes in
the files to
remove all the
warning

mem_32768x32_
tb.sv


also started to
get the
boot.mem files
compiled by
other time 

Worked with
other team mate
over this

added the
appropriate
delays before
the operations

Started giving
different bit
pattern to the
pins registers
and looped back

Once all the
verifciation work
was done I
released the
verification tag 

I was a helping
hand for the
other team mate
who was working
over this

started to work
on I2C now with
other team mate

Made Changes in
the MakeFile to
test the
bootrom

Made Changes in
the MakeFile to
test the
bootrom

instantiated
different pins
for testing

We have tried to make a block diagram for the existing bootcode. This was done to understand the process and make a custom simple code.
This boot code is part of the PULP (Parallel Ultra Low Power) platform. The goal of this BootROM is to:
Detect how the system should boot (SPI Flash, HyperFlash, JTAG, etc.).
Initialize the necessary hardware peripherals (UART, SPIM, HyperBus).
Load a binary image from Flash into L2 memory.
Jump to the entry point of the loaded program


Creating custom bootcode and compiling it -.
We have tried to create a custom bootcode that does the following operation.


Instantiated the DUT for MODE 2 testbench
Issues:
Some connections are missing (taking the reference from the clk pin). The clock of the submodules in the DUT should be connected to the CLK pin outside.

Modules
Clock status
u_io_wrapper
Visible
u_pad_mux
Visible
u_soc_domain
Not Visible

Boot_Rom Verification (Aditya, DIvyansh) - merged into main

      Objective : Checking  for  a good hex data to be  loaded into the bootrom memory.
We are able to generate good hex data and load it into our memory.
Initially considered modifying the offset at @0x80, but this was found unnecessary since our testbench reads memory content through testbench controls only.
We found (upon discussion with the design team) that in apb_soc_ctrl.sv we found no connection to the boot_rom.  Is there any design update which can be done in this ?
In apb_soc_ctrl.sv, line 213 sets the default boot address:
r_bootaddr = 32'h1A000080;
Can we change this to 32'h1A000000 to match the actual Boot ROM address?
There was a pin in the mem.slave interface (r_opc) which was unconnected.


Generating binary data from .c file - (Shrinath) - merged into main
 the RISC-V 32-bit Toolchain
. Planning the top testbench structure - (Vaibhav, Aditya)
We have made the initial testbench structure for our soc - needs more detail and modification.

Compiling tb_pulp.sv with DUT instantiated inside(Divyansh, Aditya)
The compilation commands given by Design Team was added with necessary tb packages in the makefile

Booting the DUT with Flash Method:(Vaibhav Deora, Rakesh)
Due to the proprietary nature of the s25fe256s flash model, which restricted full integration and testing, we opted to use the open-source spyflash.v model as an alternative. This allowed us to proceed with basic boot verification of the SoC without relying on an SLM (Serial Loadable Memory) file.
When we tried to run a simulation this is where we are stuck as shown in the below screenshot.
Progress so far JTAG (Shrinath)

Testbench compiles and runs with JTAG and peripheral structures instantiated.


Signal connectivity (TMS, TDI, TCK, TDO) is defined in tb_pulp.sv.


Simulation environment is stable and clock/reset domains are operating.
JTAG and peripheral interfaces are instantiated.
Problem 
The DUT is not booting. After analysis, I realized that there is no DPI-C module (e.g., jtag_dpi.c) available or connected in the current setup. This module is usually responsible for:
Driving JTAG signals (TCK, TMS, TDI),


Receiving TDO,


Loading program binaries via JTAG,


Starting execution on the DUT.
Does the current testbench environment we are using include or support a DPI-based JTAG boot mechanism (e.g., a jtag_dpi.c or equivalent)?


What is the preferred or expected method in our case to boot the DUT using JTAG via DPI?

Bootrom used in core-v-mcu soc-domain -  (Divyansh, Aditya)

We found two a2_bootrom.sv files with same instantiation in bootrom.sv-
rtl/simulation/a2_bootrom.sv - 
rtl/core-v-mcu/soc/a2_bootrom.sv - 
bootrom.sv - 

	This is the internal rom used in the core-v-mcu SoC.
	The tb/init_mem_files had a boot.mem file which contained 32 bit instructions. We have loaded that into our memory.
	boot.mem - 

 Tried to generate .hex/.bin file for booting from main.c, bootcode.c and spi.c files -  (Rakesh, Shrinath, Vaibhav)

Approach - conversion of .c → .o → .elf → .hex/.bin
The conversion can be done through:

Installing riscv32-unknown-elf-gcc compiler

There were three files(we have made the interconnections )
main.c - 
bootcode.c - 
spi.c - 

Currently we are trying to compile the three codes and generate hex files but errors are coming mostly due to absence of some files.

We followed this procedure(under debugging process)
In a2_boot directory there is a Makefile
We ran the makescripts. We got core-v-mcu_config.h(through install-core-v-mcu script) and abp_soc_ctrl_reg_defines.h(Makefile of sw/)
Debugging some internal compiler errors.

Below we have given the file dependency tree and the missing files.
Verifying the GPIO Pins. (Aditya, Divyansh)
The below block diagram contains the track of input and the output pins. But how should we loopback it? The ways we understood is:
The connection of OUTPUT to INPUT.
		The way for verifying would be through assigning values through the firmware (just that output give some patterns which is looped backed into input)

We are trying to verify the input in the GPIO pins. We have found some design issues, we will coordinate with the design team.
Update - the issue is solved				

Waveform in the current simulation:

b_pulp.sv is compiled in vcs (committed on 15th, May, 2025)
The top rtl module core-v-mcu is commented out as the wire definitions in the testbench were not correct and some were missing too. 

The following files are included and getting compiled:
/tb_pulp.sv
/tb/jtag_pkg.sv
/rtl/vendor/pulp_plateform_riscv_dgb/src/dm_pkg.sv
/tb/riscv_pkg.sv
/tb/pulp_tap_pkg.sv
/tb/SimJTAG.sv
/rtl/vip/uart_tb_rx.sv
/rtl/vip/camera/cam_vip.sv
/tb/tb_clk_gen.sv

There are some errors in the jtag_pkg.sv file, some of them are commented out.

We need the structure of the design modules that has to be verified. Since there are a large number of IPs, we need to make small hierarchical clusters that can be verified.

We need the list of the IPs and the VIPs for the testbench.
We have visualized the file hierarchy structure (Needs cleanup and bug fixing)
Link to the sheet 

We are choosing tb_pulp.sv as our top level testbench for our verification.







i had to go through to the verification of the memory block Memory (32768 X 32)	Test Name
	RESET TEST
	Initialization Test - WRITE
	Initialization Test - READ
	WRITE - Random Address Locations
	
	READ - At the WRITTEN Locations
	BYTE ENABLE TEST
	MEMORY_DISABLE TEST
	Read Disable (CHIP_EN = 1) Test
i faced many problems in it and solved it along with my team lead 


these were the momories used in the whole design 

memory name	number of words	width of each word in bits	memory size)	number of ports	pdk memory instance suitable 	number of instances to be used row wise	number of instances to be used column wise	total number of instances			
core_v_mcu_interleaved_ram_0	32768	32	128 KB	single port	gf180mcu_fd_ip_sram__sram512x8m8wm1	4	64	256			
core_v_mcu_interleaved_ram_1	32768	32	128 KB	single port	gf180mcu_fd_ip_sram__sram512x8m8wm1	4	64	256			
core_v_mcu_interleaved_ram_3	32768	32	128 KB	single port	gf180mcu_fd_ip_sram__sram512x8m8wm1	4	64	256			
core_v_mcu_interleaved_ram_4	32768	32	128 KB	single port	gf180mcu_fd_ip_sram__sram512x8m8wm1	4	64	256			
core_v_mcu_private_ram_0	8192	32	32 KB	single port	gf180mcu_fd_ip_sram__sram512x8m8wm1	4	16	64			
core_v_mcu_private_ram_1	8192	32	32 KB	single port	gf180mcu_fd_ip_sram__sram512x8m8wm1	4	16	64			
boot_rom	2048	32	8 KB	single port	gf180mcu_fd_ip_sram__sram512x8m8wm1	4	4	16			
debug_rom	19	64	152 B	single port	gf180mcu_fd_ip_sram__sram64x8m8wm1	8	1	8			
RAM_256x8_behavioral	256	8	256 B	2 port	gf180mcu_fd_ip_sram__sram256x8m8wm1	1	1	1			
core_v_mcu.u_soc_domain.soc_peripherals_i.i_udma.i_udmacore.u_tx_channels.u_fifo	4	27	13.5 B		gf180mcu_fd_ip_sram__sram64x8m8wm1	4	1	4			
core_v_mcu.u_soc_domain.soc_peripherals_i.i_udma.i_udmacore.u_rx_channels.genblk2[0].i_stream_unit.i_fifo.i_fifo	4	32	16 B		gf180mcu_fd_ip_sram__sram64x8m8wm1	4	1	4			
core_v_mcu.u_soc_domain.soc_peripherals_i.i_udma.i_udmacore.u_rx_channels.u_fifo	4	59	29.5 B		gf180mcu_fd_ip_sram__sram64x8m8wm1	8	1	8			
core_v_mcu.u_soc_domain.soc_peripherals_i.i_udma.i_udmacore.u_rx_channels.u_filter_fifo	4	38	19 B		gf180mcu_fd_ip_sram__sram64x8m8wm1	5	1	5			
core_v_mcu.u_soc_domain.soc_peripherals_i.i_udma.i_uart_gen[0].i_uart.u_fifo.i_fifo	2	8	2 B		gf180mcu_fd_ip_sram__sram64x8m8wm1	1	1	1			
core_v_mcu.u_soc_domain.soc_peripherals_i.i_udma.i_uart_gen[1].i_uart.u_fifo.i_fifo	2	8	2 B		gf180mcu_fd_ip_sram__sram64x8m8wm1	1	1	1			
core_v_mcu.u_soc_domain.soc_peripherals_i.i_udma.i_spim_gen[0].i_spim.u_cmd_fifo.i_fifo	2	32	8 B		gf180mcu_fd_ip_sram__sram64x8m8wm1	4	1	4			
core_v_mcu.u_soc_domain.soc_peripherals_i.i_udma.i_spim_gen[0].i_spim.u_fifo.i_fifo	2	32	8 B		gf180mcu_fd_ip_sram__sram64x8m8wm1	4	1	4			
core_v_mcu.u_soc_domain.soc_peripherals_i.i_udma.i_spim_gen[0].i_spim.u_spictrl.i_reply_buffer	6	33	24.75 B		gf180mcu_fd_ip_sram__sram64x8m8wm1	5	1	5			
core_v_mcu.u_soc_domain.soc_peripherals_i.i_udma.i_i2c_gen[0].i_i2c.i_i2c_tx_fifo.i_fifo	2	8	2 B		gf180mcu_fd_ip_sram__sram64x8m8wm1	1	1	1			
core_v_mcu.u_soc_domain.soc_peripherals_i.i_udma.i_i2c_gen[1].i_i2c.i_i2c_tx_fifo.i_fifo	2	8	2 B		gf180mcu_fd_ip_sram__sram64x8m8wm1	1	1	1			
core_v_mcu.u_soc_domain.soc_peripherals_i.i_udma.i_filter_gen[0].i_filter.u_tx_ch_opa.u_fifo.i_fifo	4	34	17 B		gf180mcu_fd_ip_sram__sram64x8m8wm1	5	1	5			
core_v_mcu.u_soc_domain.soc_peripherals_i.i_udma.i_filter_gen[0].i_filter.u_tx_ch_opb.u_fifo.i_fifo	4	34	17 B		gf180mcu_fd_ip_sram__sram64x8m8wm1	5	1	5			
core_v_mcu.u_soc_domain.soc_peripherals_i.i_udma.i_filter_gen[0].i_filter.u_rx_ch.i_fifo	4	32	16 B		gf180mcu_fd_ip_sram__sram64x8m8wm1	4	1	4			
core_v_mcu.u_soc_domain.soc_peripherals_i.i_udma.i_sdio_gen[0].i_sdio.i_sdio_tx_fifo.i_fifo	2	32	8 B		gf180mcu_fd_ip_sram__sram64x8m8wm1	4	1	4			
core_v_mcu.u_soc_domain.fc_subsystem_i.lFC_CORE.if_stage_i.prefetch_buffer_i.fifo_i	2	32	8 B		gf180mcu_fd_ip_sram__sram64x8m8wm1	4	1	4			

the initial tasks were like 
 when the project started 

Understand the working of the files in the tb
Run the TB for Existing RTL
Making the Initial Block Diagram
Making the file structure of tb
Defining the verification modules and vips
Fix the core-v-mcu instantiation in tb-pulp.sv
Fix and run the boot step in the DUT
Fix and run JTAG
Setting up a2_bootrom and boot.mem files
Installing risc32-unknown-elf-gcc 
Setting up verdi functions
Debugging the compilation errors of .c boot file
Fixing up the custom functions in the testbench environment



i also worked on boot loader with one of the senior 
BootLoaderI2CInstructionSpecifications


Datauction-Length		1st cycle	2nd cycle	3rd cycle	4th cycle	5th cycle	6th cycle		Returns Stat	
2	GPIO Wr	F_0	[7:4: Value] [3:0:  GPIO Pin Number]					"Value :
00:  Make Pin 0 
01:  Make Pin 1
10:  Toggle Value of Pin 
11:   RES"	Yes	Writes 0,1 to the pin or toggles its value
2	GPIO IN RD	F_1	[7:4: RES] [3:0 : GPIO Pin Number] 						Yes	Reads value of the GPIO pin 
2	GPIO OUT RD	F_2	[7:4: RES] [3:0 : GPIO Pin Number] 							
2	GPIO Change Pin Type	F_3	[7:4: Type] [3:0 : GPIO Pin Number] 					"Type :
Encoding for available GPIO types (Open Drain etc) 
00:input
01:ouput
11:open - drain"	Yes	
										
1	ResetMemWrPointer	E_0							Yes	
2	ChangeMemWrPointer	E_1	Memory Addr[31:24]	Memory Addr[23:16]	Memory Addr[15:8]	Memory Addr[7:0]			Yes	Changes the value of CurrentMemPointer to this value
5	WriteDataAtCurMemWrPointer	E_2	Data[31:24]	Data[23:16]	Data[15:8]	Data[7:0]			Yes	Loads the data in next 4 cycles at the location pointed to by the CurrentMemWrPointer
									Yes	
1	ResetMemRdPointer	E_3							Yes	
2	ChangeMemRdPointer	E_4	Memory Addr[31:24]	Memory Addr[23:16]	Memory Addr[15:8]	Memory Addr[7:0]			Yes	Changes the value of CurrentMemPointer to this value
5	ReadDataAtCurMemRdPointer	E_5							Yes	Reads the data at the CurrentMemRdPointer and sends out on the SPI slave port
1	AddJmpToBootInCode	E_6							Yes	"Adds a Jump back to Boot loop Datauction at the CurrentMemoryPointer
A statemachine in memory should monitor that code is safe to execute"
1	AddHaltToCode	E_7							Yes	Adds Halt Datauction at CurrentMemPointer
2	JumpToCodeAtAddress	E_8	Memory Addr[31:24]	Memory Addr[23:16]	Memory Addr[15:8]	Memory Addr[7:0]			Yes	
1	JumpToStartOfCodeSegment	E_9							Yes	
1	CheckIfReady	D_0							MayBe	"There is no guarantee that this message will be responded back.  If no response, the external processor has to wait for a timeout, and try again. 

Once response starts to come back, external processor has to wait for responses to all the CheckIfReady Commands it has already sent if responses received are 5_0. If external processor receives 5_1, that means the core_v_mcu has responded to all pending ChkIfReady commands and is now ready to accept new commands. "
2	ChangeSlaveAddress	D_1	Slave_Address						Yes	change I2c slave address
1	AddJmpToFunction	D_2							Yes	Adds Jump back to next instruction of same function In bootrom(for post execution Response) by reading address from scratch area at 0x1c00_0008
										
Slave To Master										
2	GPIO Wr  Response	A_0	"Fail :  F_0 
Success : 5_0"							
2	GPIO IN RD  Response	A_1	"Fail :  F_0 
Success :  5_[pin-value]"							
2	GPIO OUT RD Response	A_2	"Fail :  F_0 
Success :  5_[pin-value]"							
2	GPIO Change Pin Type  Response	A_3	"Fail :  F_0 
Success : 5_0"							
2	ResetMemWrPointer  Response	B_0	"Fail :  F_0 
Success : 5_0"							
2	ChangeMemWrPointer  Response	B_1	"Fail :  F_0 
Success : 5_0"							
2	WriteDataAtCurMemWrPointer  Response	B_2	"Fail :  F_0 
Success : 5_0"							
2	ResetMemRdPointer  Response	B_3	"Fail :  F_0 
Success : 5_0"							
2	ChangeMemRdPointer  Response	B_4	"Fail :  F_0 
Success : 5_0"							
6	ReadDataAtCurMemRdPointer  Response	B_5	"Fail :  F_0 
Success : 5_0"	Data[31:24]	Data[23:16]	Data[15:8]	Data[7:0]			
2	AddJmpToBootInCode  Response	B_6	"Fail :  F_0 
Success : 5_0"							
2	AddHaltToCode  Response	B_7	"Fail :  F_0 
Success : 5_0"							
2	JumpToCodeAtAddress  Response-1 (PreExecute)	B_8	"Fail :  F_0 
Success : 5_0"							Response is sent before the actual jump to code segment occurs, indicating the start of execution
2	JumpToCodeAtAddress  Response-1 (PostExecute)	B_9	"Fail :  F_0 
Success : 5_1"							Response is sent after the control returns to boot code, indicating the end of execution
2	JumpToStartOfCodeSegment Response-2 (PreExecute)	B_A	"Fail :  F_0 
Success : 5_0"							Response is sent before the actual jump to code segment occurs, indicating the start of execution
2	JumpToStartOfCodeSegment Response-2 (PostExecute)	B_B	"Fail :  F_0 
Success : 5_1"							Response is sent after the control returns to boot code, indicating the end of execution
1	Ready	C_0	"Fail :  F_0 
Success : 5_0/5_1"							"Response can be delayed.
5_0 means each command received will be responded back 
5_1 means, I am responding only once, and will not respond to other CheckIfReady Commands. They will be dropped. "
2	ChangeSlaveAddress Response	C_1	"Fail :  F_0 
Success : 5_0"							
2	AddJmpToFunction	C_2	"Fail :  F_0 
Success : 5_0"							


pdk details 

cells	input pins			output pins			cell functionality
	pin name	pin width	description	pin name	pin width	description	
gf180mcu_fd_ip_sram__sram512x8m8wm1	CLK		clock	Q	[7:0] 8bits	Data Output(read)	"For all the cells listed in the sheet:







Read
        CEN:0
        GWEN:1
        WEN: Not taken into account during read
        Q<= Mem[A]
Write(all bits)
        CEN:0
        GWEN:0
        WEN: 8’b00000000 (all bits Enabled to write)
        Mem[A]<=D
Write( For Selected bits)
        CEN:0
        GWEN:0
        WEN: 8’bxxxxxxxx (If 0 then write to that bit; if 1 ignore that bit)
        Mem[A]<=D
"
	CEN		Chip Enable				
	GWEN		Global Write Enable				
	WEN	[7:0] 8bits	Write Enable				
	A	[8:0] 9bits	Address				
	D	[7:0] 8bits	Data Input (write)				
							
	VDD		Power				
	VSS		Ground				
gf180mcu_fd_ip_sram__sram256x8m8wm1	CLK		clock	Q	[7:0] 8bits	Data Output(read)	
	CEN		Chip Enable				
	GWEN		Global Write Enable				
	WEN	[7:0] 8bits	Write Enable				
	A	[7:0] 8bits	Address				
	D	[7:0] 8bits	Data Input (write)				
	VDD		Power				
	VSS		Ground				
gf180mcu_fd_ip_sram__sram128x8m8wm1	CLK		clock	Q	[7:0] 8bits	Data Output(read)	
	CEN		Chip Enable				
	GWEN		Global Write Enable				
	WEN	[7:0] 8bits	Write Enable				
	A	[6:0] 7bits	Address				
	D	[7:0] 8bits	Data Input (write)				
	VDD		Power				
	VSS		Ground				
gf180mcu_fd_ip_sram__sram64x8m8wm1	CLK		clock	Q	[7:0] 8bits	Data Output(read)	
	CEN		Chip Enable				
	GWEN		Global Write Enable				
	WEN	[7:0] 8bits	Write Enable				
	A	[5:0] 6bits	Address				
	D	[7:0] 8bits	Data Input (write)				
	VDD		Power				
	VSS		Ground				

	RV32I Base Instruction Set
																																		
Sl no.	instruction 	Instruction Type	Instruction definition	Instruction structure																															
				B31	B30	B29	B28	B27	B26	B25	B24	B23	B22	B21	B20	B19	B18	B17	B16	B15	B14	B13	B12	B11	B10	B9	B8	B7	B6	B5	B4	B3	B2	B1	B0
1	JAL (Jump and Link)	Control Transfer Instructions                                                                                          Unconditional Jumps	The jump and link (JAL) instruction uses the UJ-type format, where the J-immediate encodes a signed offset in multiples of 2 bytes. The offset is sign-extended and added to the pc to form the jump target address. Jumps can therefore target a ±1 MiB range. JAL stores the address of the instruction following the jump (pc+4) into register rd. The standard software calling convention uses x1 as the return address register.	imm[20]	imm[10:1] 										imm[11]	imm[19:12]								rd					opcode - 1101111						
				offset[20:1]																				dest					JAL						
2	JALR (Jump and Link Register)	Control Transfer Instructions                                                                                          Unconditional Jumps	"The indirect jump instruction JALR (jump and link register) uses the I-type encoding. The target
address is obtained by adding the 12-bit signed I-immediate to the register rs1, then setting the
least-significant bit of the result to zero. The address of the instruction following the jump (pc+4)
is written to register rd. Register x0 can be used as the destination if the result is not required."	imm[11:0]												rs1					funct3 - 000			rd					opcode - 1100111						
				offset[11:0]												base					funct3			dest					JALR						
3	BEQ	Conditional Branches	"All branch instructions use the SB-type instruction format. The 12-bit B-immediate encodes signed
offsets in multiples of 2, and is added to the current pc to give the target address. The conditional
branch range is ±4 KiB.                                                                                                                                                                                                                                                                                                                    1.Branch instructions compare two registers. BEQ and BNE take the branch if registers rs1 and rs2
are equal or unequal respectively.                                                                                                                                                                                                                                                                                 2.BLT and BLTU take the branch if rs1 is less than rs2, using signed and unsigned comparison respectively.                                                                                                                                                                      3.BGE and BGEU take the branch if rs1 is greater
than or equal to rs2, using signed and unsigned comparison respectively.                                                                                                                                                                                                                    Note, BGT, BGTU,
BLE, and BLEU can be synthesized by reversing the operands to BLT, BLTU, BGE, and BGEU,
respectively"	imm[12]	imm[10:5]						rs2					rs1					funct3 - 000			imm[4:1] 				imm[11] 	opcode - 1100011						
4	BNE			imm[12]	imm[10:5]						rs2					rs1					funct3 - 001			imm[4:1] 				imm[11]	opcode - 1100011						
5	BLT			imm[12]	imm[10:5]						rs2					rs1					funct3 - 100			imm[4:1] 				imm[11] 	opcode - 1100011						
6	BLTU			imm[12]	imm[10:5]						rs2					rs1					funct3 - 110			imm[4:1] 				imm[11] 	opcode - 1100011						
7	BGE			imm[12]	imm[10:5]						rs2					rs1					funct3 - 101			imm[4:1] 				imm[11]	opcode - 1100011						
8	BGEU			imm[12]	imm[10:5]						rs2					rs1					funct3 - 111			imm[4:1] 				imm[11]	opcode - 1100011						
				offset[12,10:5]							src2					src1					BEQ/BNE/BLT[U]/BGE[U]			offset[11,4:1]					BRANCH						
9	SB (Store Byte)	 Load and Store Instructions	"RV32I is a load-store architecture, where only load and store instructions access memory and
arithmetic instructions only operate on CPU registers. RV32I provides a 32-bit user address space
that is byte-addressed and little-endian. The execution environment will define what portions of
the address space are legal to access.
Load and store instructions transfer a value between the registers and memory. Loads are encoded
in the I-type format and stores are S-type. The effective byte address is obtained by adding register
rs1 to the sign-extended 12-bit offset. Loads copy a value from memory to register rd. Stores copy
the value in register rs2 to memory.                                                                                                                                                                                                                                                                                                                                                                        The LW instruction loads a 32-bit value from memory into rd.                                                                                                                                                                                                                                                                                                                   LH loads a 16-bit value from memory,
then sign-extends to 32-bits before storing in rd.                                                                                                                                                                                                                                                                                                                                                    LHU loads a 16-bit value from memory but then
zero extends to 32-bits before storing in rd.                                                                                                                                                                                                                                                                                                                                                                    LB and LBU are defined analogously for 8-bit values.
The SW, SH, and SB instructions store 32-bit, 16-bit, and 8-bit values from the low bits of register
rs2 to memory.
"	imm[11:5]							rs2					rs1					funct3 - 000			imm[4:0]					 opcode -100011						
10	SH (Store Half)			imm[11:5]							rs2					rs1					funct3 - 001			imm[4:0]					 opcode -100011						
11	SW (Store Word)			imm[11:5]							rs2					rs1					funct3 - 010			imm[4:0]					 opcode -100011						
				offset[11:5]							src					base					funct3			 offset[4:0]					STORE						
12	LB (Load Byte)			imm[11:0] 												rs1					funct3 - 000 			rd					 opcode - 0000011						
13	LH (Load Half)			imm[11:0] 												rs1					funct3 - 001			rd					 opcode - 0000011						
14	LW (Load Word)			imm[11:0] 												rs1					funct3 - 010 			rd					 opcode - 0000011						
15	LBU (Load Byte Unsigned)			imm[11:0] 												rs1					funct3 - 100			rd					 opcode - 0000011						
16	LHU (Load Half Unsigned)			imm[11:0] 												rs1					funct3 - 101			rd					 opcode - 0000011						
				offset[11:0]												base					funct3			dest					LOAD						
17	LUI (load upper immediate)	Integer Computational Instructions                                            Integer Register-Immediate Instructions
	"LUI (load upper immediate) is used to build 32-bit constants and uses the U-type format. LUI
places the U-immediate value in the top 20 bits of the destination register rd, filling in the lowest
12 bits with zeros.
"	imm[31:12] 																				rd					 opcode - 0110111						
				U-immediate[31:12]																				dest					LUI						
18	AUIPC (add upper immediate to pc)	Integer Computational Instructions                                            Integer Register-Immediate Instructions
	"AUIPC (add upper immediate to pc) is used to build pc-relative addresses and uses the U-type
format. AUIPC forms a 32-bit offset from the 20-bit U-immediate, filling in the lowest 12 bits with
zeros, adds this offset to the pc, then places the result in register rd.
"	imm[31:12] 																				rd					 opcode - 0010111						
				U-immediate[31:12]																				dest					AUIPC						
19	ADDI (Add Immediate)	Integer Computational Instructions                                            Integer Register-Immediate Instructions
	"ADDI adds the sign-extended 12-bit immediate to register rs1. Arithmetic overflow is ignored and
the result is simply the low XLEN bits of the result. ADDI rd, rs1, 0 is used to implement the MV
rd,  rs1 assembler pseudo-instruction.
"	imm[11:0] 												rs1					funct3 - 000			rd					 opcode - 0010011						
20	SLTI (set less than immediate)	Integer Computational Instructions                                            Integer Register-Immediate Instructions
	SLTI (set less than immediate) places the value 1 in register rd if register rs1 is less than the signextended immediate when both are treated as signed numbers, else 0 is written to rd. SLTIU is similar but compares the values as unsigned numbers (i.e., the immediate is first sign-extended to XLEN bits then treated as an unsigned number). Note, SLTIU rd, rs1, 1 sets rd to 1 if rs1 equals zero, otherwise sets rd to 0 (assembler pseudo-op SEQZ rd, rs).	imm[11:0] 												rs1					funct3 - 010			rd					 opcode - 0010011						
21	SLTIU(set less than immediate unsigned)	Integer Computational Instructions                                            Integer Register-Immediate Instructions
		imm[11:0] 												rs1					funct3 - 011			rd					 opcode - 0010011						
22	XORI(Exclusive Or with Immediate)	Integer Computational Instructions                                            Integer Register-Immediate Instructions
	ANDI, ORI, XORI are logical operations that perform bitwise AND, OR, and XOR on register rs1 and the sign-extended 12-bit immediate and place the result in rd.	imm[11:0] 												rs1					funct3 - 100			rd					 opcode - 0010011						
23	ORI(Exclusive Or with Immediate)	Integer Computational Instructions                                            Integer Register-Immediate Instructions
		imm[11:0] 												rs1					funct3 - 110			rd					 opcode - 0010011						
24	ANDI (And with Immediate)	Integer Computational Instructions                                            Integer Register-Immediate Instructions
		imm[11:0] 												rs1					funct3 - 111			rd					 opcode - 0010011						
				I-immediate[11:0]												src					funct3			dest					OP-IMM						
25	SLLI (Shift Left Logical by Immediate)	Integer Computational Instructions                                            Integer Register-Immediate Instructions
	"Shifts by a constant are encoded as a specialization of the I-type format. The operand to be shifted is in rs1, and the shift amount is encoded in the lower 5 bits of the I-immediate field. The right shift type is encoded in a high bit of the I-immediate. SLLI is a logical left shift (zeros are shifted
into the lower bits); SRLI is a logical right shift (zeros are shifted into the upper bits); and SRAI is an arithmetic right shift (the original sign bit is copied into the vacated upper bits)."	imm[11:5] = 0000000							imm[4:0]					rs1					funct3 - 001			rd					 opcode - 0010011						
26	SRLI(Shift Right Logical by Immediate)	Integer Computational Instructions                                            Integer Register-Immediate Instructions
		imm[11:5] = 0000000							imm[4:0]					rs1					funct3 - 101			rd					 opcode - 0010011						
27	SRAI (Shift Right Arithmetically by Immediate)	"Integer Computational Instructions                                            Integer Register-Immediate Instructions
"		imm[11:5] = 0100000							imm[4:0]					rs1					funct3 - 101			rd					 opcode - 0010011						
				imm[11:5] 							shamt[4:0]					src					funct3			dest					OP-IMM						
28	ADD	"Integer Computational Instructions                                            Integer Register-Register Operations
"	ADD perform addition. Overflows are ignored and the low XLEN bits of results are written to the destination.	funct7 = 0000000							rs2					rs1					funct3 - 000			rd					 opcode - 0110011						
29	SUB	"Integer Computational Instructions                                            Integer Register-Register Operations
"	SUB perform  subtraction. Overflows are ignored and the low XLEN bits of results are written to the destination	funct7 = 0100000							rs2					rs1					funct3 - 000			rd					 opcode - 0110011						



25/05/2025	Verification Team	Compilation of .c instruction to binary (.hex) for memory reading
27/05/2025	Verification Team	Verified BootROM
16/06/2025	Verification Team	Compiling TestBench without warning or errors with contemporary DUT
25/06/2025	Verification Team	Standalone Memory Verified

28/06/2025	Verification Team	Programming the SoC with first custom bootcode
25/06/2025	Verification Team	Standalone Memory Verified
28/06/2025	Verification Team	Programming the SoC with first custom bootcode
03/07/2025	Verification Team	GPIO Pins Verified
11/07/2025	Verification Team	Updated I2CS design verified successfully 
17/07/2025 	Verification Team	Verified the above updated design 
18/07/2025	Verification Team	Verified the above updated design 
19/07/2025	Verification Team	Verified the above updated design.                                                                                                                                                                                                    The first verification tag was released
Design + Verif	"A new proposal to boot the Core-V-MCU from external agent is worked out. With this the processor will be usable for a wide range of tasks 

ApproachToBootCode"
	01/08/2025	Verification	SRAM (256X32) has been verified
04/08/2025	Verification Team	Automated verification framework enables running multiple tests with a single command and generates a summary output for easy tracking.



23-May-2025		Other Learnings	
	wafer, die , pad ring, package, package pins		Status reporting
	GPIO pads, input Pads, output Pads, How to configure them ? What is the structure and what do control pins do 		Keeping record of runs 
	Concept of Control and Status Registers and How they are designed		Feasibility of implementing a design within constrains
	Using Programmable Registers to control IO , How are functional GPIO made		
	What is the port-extender? How to use a peripheral like I2C to make a port extender		
13-June-2025		Assignments/Activities	RTL updates 
	Concept of boot and how bootsel pin can be used to load the program counter differently		Code Management in GITHUB
	More on port extender using core-v-mcu		Verification & Verif Automation 
	How to find all memories in the design 		Port Map, Address Map Management
	How to use defines and `ifdef to remove parts of the design 		Peripherals , SOC designs and issues 
20-June-2025			
	Debuging the code. 	Documents	
	How OE of a tri-state pin can be used to create a signal. 		DESIGN_SIDHARUD1
	Boot Code and Boot Process		Sidharud-IO-definitionSheet
			BootLoaderI2CInstructionSpecifications
28 - June - 2025			
	Understanding of io extender		
	Analysing PDK Files		
4-July-2025			
	Concept of Direct Memory Access (DMA)		
	What is a SoC 		
	Address Map of the processor. Not all addresses need to be populated		
	Peripheral Design for a SoC 		
	Typical Driver Code :  Interrupt Driven, Polling Driven 		
11-July-2025			
	Using I2C to implement a port extender and control and read GPIO pins		
	A conceptual I2C based external instruction set		
	Detecting NegEdge and PosEdge of the signal 		
	Concept of JTAG 		
	Using JTAG signals to load the memory and execute it 		
2 - August - 2025	Understanding of io cells		
	Structure of power io cells		
	Pad Ring Structure		

apart from these works i also help in physical design team 
 i implemented all the 3 versions of the updated scripts and whenever faced any error or warning i  looked for  the prbable solution and passed it back with the feedback to the team  or myself corrected them if it was possible at that moment 
pd_flow_v0 / v1/ v2 
		
i even helped in netlist verification  manually and also help in doing so using formality with the other seniors 


in the bootloader these things were done by the senior and me 

							
7	6	5	4	3	2	1	0
OPCODE		VALUE		GPIO PIN NUMBER			
							
							
Formats		Master ----> Slave (COMMAND)					
		Slave ----> Master (RESPONSE)					
	Master ----> Slave (COMMAND)					
	OPCODE		0	0	Read to GPIO	
			0	1	Write to GPIO	
			1	0	Reserved	
			1	1	Open Drain	
	VALUE(Valid only in WRITE operation)		0	0	LOW	
			0	1	HIGH	
			1	0	TOGGLE	
Slave ----> Master (RESPONSE)					
OPCODE		0	0	Read Failure	
		0	1	Read Success	
		1	0	Unexplained Error	
		1	1	Write Acknoledgement	
VALUE		0	0	LOW is Read	
		0	1	HIGH is Read	
		1	0	Unknown Value(X)	
		1	1	Reserved	

Registers Required(For Individual Pin Reading)			
GPIO - Base Address	0x1A101000		
For Writing in GPIO OUTPUT	Set Direction	0x1A101038	[25:24] = 01
			[6:0] - GPIO PIN
	Write HIGH	0x1A101000	[6:0] - GPIO PIN
	Write LOW	0x1A101004	[6:0] - GPIO PIN
	Write TOGGLE	0x1A101008	[6:0] - GPIO PIN
Acknowledge that value is Written	REG_RDSTAT	0x1A101034	[8] - OUTPUT VALUE
			[6:0] - GPIO PIN
For Reading in GPIO INPUT	REG_SETSEL	0x1A101030	[6:0] - GPIO PIN
	REG_RDSTAT	0x1A101034	[12] - INPUT VALUE
			[6:0] - GPIO PIN

instruction set example 
Our processor takes the instruction in BIG ENDIAN format	
Each instruction is 32 bits wide	
	
Example	
li x6, 0x1A101020 	 REG_OUT0 address (base + 0x020)
li x7, 0x00001FFF 	 Data to write to GPIO
sw x7, 0(x6)	 Write to REG_OUT0
	
RISC-V toolchain (like riscv32-unknown-elf-gcc and objdump) expands compressed instructions in the disassembly view for readability and clarity, even though they’re encoded more compactly in memory.	
	
Expanded Instruction	Equivatent Hex Instruction
lui t1,0x1a101	1a101337
"addi	t1,t1,32 # 1a101020"	02030313
"lui	t2,0x2"	00006389
"addi	t2,t2,-1 # 1fff"	000013fd 
"sw	t2,0(t1)"	00732023
	
Final Instructions loaded into BootROM - 32 Bit Instruction in  BIG ENDIAN format	
1a101337	 LUI t1, 0x1A101
02030313	ADDI t1, t1, 32
13fd6389  	LUI t2, 0x2; ADDI t2, t2, -1
00732023	SW t2, 0(t1)

first byte (opcode) from master		Expected Payload from I2C Master		 description 					response from up to i2c master	
										
0x01 (load_instruction)		2bytes (N) + N × 4 bytes (instructions)		Loads N 32-bit instructions into RAM starting at address 0x1C000000					0xAB (ACK response)	
0x02(jump_to_ram)		none		Starts execution from RAM address 0x1C000000					0xA2	
0x03 (immediate_execute)		4 bytes (instruction		Executes a single 32-bit instruction loaded immediately into RAM.					0xA1	
Invalid Opcode		none		Unrecognized opcode					0xE0	



so far i have tried to give you everything that i have done in this project or have collaborated with other son or others have done and i have learnt fromt  that so now 
i order to give a detailed report of my work i want you to create a report and i will give you the mail again so  that you know what to do 


Jagadish N <jagadishdn@iiitdwd.ac.in>
Oct 8, 2025, 11:01 AM
to sidharud1, HOD

Dear students,

Many congratulations on the tapeout of the SIDHARUD1 chip. There has been a lot of effort from everyone of you in making the task possible.

Moving forward, as you have expressed interest to earn credit for the effort, you are requested to furnish a detailed report on the work you carried out in the SIDHARUD project (emphasizing the task/spec, proposed method, analysis, code/script, outcomes, contribution etc...) at individual level. Your work shall be reviewed and asked to present in front of a review panel.


and also  i got mail 
Deal all,

As part of the project/activity evaluation process, the assessment panel will review each submission based on the following criteria:

Relevance of the activity to the student’s academic program or learning objectives.

Quality and completeness of the documentation submitted (e.g., certificates, reports, project outcomes).

Outcomes achieved, including skills developed, problem-solving ability, or innovation demonstrated.

Presentation or viva, to assess understanding and engagement.

Note: Based on the panel’s recommendations, appropriate credits and grades will be awarded to the students.

--

so now do it 

SIDHARUD1 — Individual Contribution Report
Author: [Your Name]
Role: Verification engineer (primary); contributed to bootloader development and physical design support
Period: Project duration (5 months) — highlights and timeline included

1. Executive summary
I contributed to the SIDHARUD1 tapeout project primarily as a verification engineer and later as a contributor to bootloader development and physical-design support. My work spanned creation and maintenance of verification infrastructure, testbench and memory verification, boot ROM and bootloader validation, coordination with design and PD teams, and writing/updating scripts and flows needed for simulation and PD. The deliverables include testbenches, Makefile improvements, temporary peripheral models, memory verification reports, boot ROM testbenches and binaries, and multiple PD flow script versions with iterative fixes.

2. Project scope and my responsibilities
- Project goal: A multi-mode SoC (four modes planned) to be fabricated through collaboration with Synopsys and GlobalFoundries. Area constraints limited successful implementation to Mode-1 (QSPI, I2C-M, I2C-S, UART with JTAG enabled by default).
- My responsibilities:
    - Verification: plan, run and document verification for SoC blocks and memories; create testbenches; maintain MoMs and verification artifacts; produce summary reports.
    - Bootloader & boot ROM: help build boot binaries and test boot sequencing via SPI/JTAG methods; create and validate boot.mem and init files.
    - Physical-design support: implement PD script versions, triage PD errors/warnings, run netlist vs RTL comparisons, assist with formality checks.

3. System, modes and implemented subset
- Planned modes: four (covering combinations of QSPI, SDIO, multiple UARTs, I2C masters/slaves, port extender). Only Mode-1 was implemented due to area constraints.
- Implemented interfaces for Mode-1: JTAG (default), QSPI Flash boot method support (via spyflash.v), I2C (master & slave where applicable), UART, and a set of GPIO/FGPIO pads.

4. Pinout, pad usage and boot selection
- Worked with the pad map for mode-1: clock, reset, JTAG pins (TCK/TMS/TDI/TDO/TRST mapped to FGPIO when JTAGEN=0), boot mode select, and multiple FGPIO inputs/outputs plus I2C pins (SCL/SDA).
- Ensured testbench used correct external pad connectivity for DUT instantiation and validated directional behavior for tri-state/pad OE semantics.

5. Verification work — tasks and outcomes
5.1 Verification planning and documentation
- Maintained meeting minutes (MoM) and verification documentation for tasks, test coverage and progress tracking.
- Defined verification modules, VIPs (UART VIP, JTAG structures, SPI flash model), and the top-level TB selection (tb_pulp.sv).

5.2 Testbench and simulation infrastructure
- Created and modified Makefiles to:
    - Build the testbench with required packages and compile options.
    - Add commands for launching tools such as Verdi and waveform collection.
    - Integrate simulation compile rules for the DUT and TB packages.
- Added temporary spyflash model (open-source spiflash.v) to replace proprietary flash model and enable boot-from-flash simulations.
- Wrote temporary/peripheral testbenches for the spiflash method and bootrom unit tests; later merged selected components into the top testbench.

5.3 Boot ROM and boot process verification
- Created a separate boot ROM testbench and debugging harness to validate boot ROM content and boot sequence behavior.
- Confirmed boot ROM content could be loaded from generated hex files and boot.mem files; validated instruction formats and endianness assumptions.
- Discovered missing connections in apb_soc_ctrl->boot_rom path; validated r_bootaddr default and proposed address alignment adjustments (coordination with design team required for final change).
- Verified boot ROM readback behavior and testbench-driven memory reads.

5.4 Memory verification (major task)
- Performed standalone functional verification of major SRAM macros used in the design; primary memory verified: 32768 x 32 (interleaved memories), private RAM, boot ROM, debug ROM and numerous small FIFOs.
- Test coverage for memory block (32768 x 32):
    - RESET, initialization (WRITE), read-after-write, random address writes/reads, byte-enable tests, memory-disable chip enable tests, and read-disable tests.
- Replaced and reorganized initialization files (mem_init_files -> mem_init_files_old; created new mem init set) to ensure deterministic TB behavior.
- Addressed and removed glitches on random reads; added delays and timing adjustments for stable memory initialization during simulation.

5.5 Peripherals and GPIO verification
- Verified I2C (used for port extender functionality) with firmware test vectors; produced a firmware_for_verification.txt containing recommended assembly snippets and instruction sequences for tests.
- Verified GPIO read/write/toggle semantics via both testbench stimulus and small bootloader sequences. Resolved design issues where input/output loopback failed.
- Removed compilation warnings from RTL + TB combinations and iterated on TB to ensure clean simulation compilation.

5.6 JTAG and DPI issues
- Brought up JTAG infrastructure in the testbench: signals TCK/TMS/TDI/TDO mapped in TB.
- Identified missing DPI-C components (e.g., jtag_dpi.c or equivalent) required for DPI-based JTAG boot/load sequences; documented the absence and proposed options:
    - Add/restore DPI-C jtag model to load binaries and drive JTAG sequences.
    - Use an alternative SPI-flash based boot method (which we used via spyflash.v) when DPI-JTAG is unavailable.
- Created a list of expected DPI responsibilities: drive TCK/TMS/TDI, capture TDO, load binaries via JTAG, start execution on DUT.

6. Firmware and toolchain work
- Assisted in producing binary/hex images from C sources using RISC-V toolchain flow: .c -> .o -> .elf -> .hex/.bin with riscv32-unknown-elf-gcc and objdump.
- Debugged build issues in the software Makefile (missing headers, config files produced by install scripts).
- Validated final instruction words (big-endian format expected by bootrom load approach) and tested writing of instruction words to boot.mem.

7. Bootloader instruction set & test sequences
- Participated in specification and verification of a small I2C-based bootloader instruction set used for remote command/control of the boot ROM.
- Validated command/response encodings for operations such as GPIO write/read/toggle, memory write/read, change pointers, jump to code, and check-if-ready responses.
- Implemented and validated representative sequences for loading multiple instructions and initiating execution (examples: load_instruction, jump_to_ram, immediate_execute).

8. Physical design (PD) support and netlist verification
- Implemented and validated multiple versions of the PD flow scripts (pd_flow_v0, v1, v2). For each:
    - Ran flows, captured warnings/errors, triaged root cause, and provided fixes or actionable feedback to the PD/design teams.
- Performed netlist verification:
    - Comparison of RTL vs synthesized netlist (structural checks to ensure functional equivalence).
    - Used formality for formal equivalence where applicable and manual checks for cell mapping and instances.
- Cross-checked PDK cell usage and instance counts (mapped SRAM macros to GF PDK cells and verified address/width constraints).

9. Automation and release
- Reorganized Makefiles and test targets to allow:
    - Single-command execution of canonical verification scenarios.
    - Verdi wave launch targets and report generation.
- Released a verification tag once regression benchmarks and tests were stable.

10. Collaboration, coordination and mentoring
- Coordinated with design, software and PD teams on required design changes (boot address, connecting boot_rom interfaces, missing pins).
- Helped teammates with debugging boot.mem generation, testbench issues and memory test sequences.
- Co-authored portions of verification documentation and test plans; maintained run logs and error reports on shared drive.

11. Key artifacts delivered
- Testbenches: bootrom TB, memory TB (mem_32768x32_tb.sv), top-level TB modifications (tb_pulp.sv integration).
- Temporary models: spiflash.v integration to replace proprietary flash.
- Makefile and run scripts: compile, simulation and Verdi run commands; memory init file reorganization.
- Boot ROM image generation procedure (.c → .hex/.bin steps) and example binaries.
- PD scripts: pd_flow_v0/v1/v2 and run logs with fixes and notes.
- Verification reports: memory verification summary, boot ROM validation notes, list of open issues and resolved items.

12. Test results (summary)
- Standalone memory (32768x32) — standalone verification PASS for listed functional tests.
- Boot ROM — validated boot.mem load and memory readback; boot-from-spi was tested using spyflash.v (basic verification passed); JTAG-based DPI boot not functional due to missing DPI model.
- I2C port extender functionality — verified basic operation and added assembly sequences for firmware-driven tests.
- GPIO — read/write/toggle behavior validated; loopback and firmware tests passed after fixing pin routing issues.

13. Known issues and limitations
- Proprietary flash model (s25fe256s) could not be integrated; spyflash.v used as substitute for functional verification (sufficient for boot sequencing tests but not full timing/behavioral match).
- DPI-C JTAG module (jtag_dpi.c) absent in current environment; prevents direct DPI-based JTAG boot automation; recommended action: add the DPI model or use an alternative loader.
- Some top-level DUT pin connections were missing in TB instantiation (clock routing to submodules); these were identified and logged.
- Minor boot address mismatch noted in apb_soc_ctrl default (discussed change from 0x1A000080 to 0x1A000000 with design team).

14. Timeline (selected milestones)
- 25/05/2025 — Start: compilation of .c -> binary for memory reading.
- 27/05/2025 — BootROM verification validated.
- 16/06/2025 — Testbench compiled cleanly with DUT.
- 25/06/2025 — Standalone memory verified.
- 28/06/2025 — First custom bootcode programmed and tested.
- 03/07/2025 — GPIO verification completed.
- 11/07/2025 — Updated I2C design verification completed.
- 01/08/2025 — Verification: additional SRAM variants verified.
- 04/08/2025 — Automation: single-command verification framework with summary output implemented.
(Other dated entries recorded in verification logs and MoM.)

15. Skills and learning outcomes
- Hands-on verification methodology (testbench architecture, directed tests, regression automation).
- RISC-V toolchain usage and binary generation for embedded boot sequences.
- Peripheral verification (I2C, UART), memory testing, boot ROM characterization.
- PD flow familiarity, netlist verification, and PDK SRAM mapping.
- Use of simulation/debug tools (VCS, Verdi), and debugging cross-domain issues (RTL/PB/PD).

16. Recommendations and next steps
- Integrate a DPI-C JTAG model or equivalent loader to enable automated JTAG-based boot sequences and to exercise debug interactions.
- Replace spyflash.v with the vendor flash model if licensing allows for final timing/functional sign-off, or enhance the spyflash model to approximate key timing behaviors.
- Finalize the boot address and apb_soc_ctrl connection updates after a design review and commit changes to RTL if agreed.
- Expand regression tests to cover:
    - Full boot-from-flash negative/edge cases.
    - JTAG load/resume scenarios once DPI is available.
    - Peripheral stress tests (I2C multi-master scenarios, UART throughput).
- Consolidate the TB file and package structure to a canonical repository location, document run scripts and add CI integration for nightly regressions.

17. How to reproduce key verification runs (commands & notes)
- Use the provided Makefile targets in the verification repository:
    - make compile_tb
    - make sim_tb (with TARGET=bootrom or TARGET=memory)
    - make run_verdi
- Steps to build boot image from C (high level):
    - Install riscv32-unknown-elf-gcc toolchain.
    - Build sources via provided a2_boot Makefile: make all (resolve missing headers using install-core-v-mcu script artifacts).
    - Convert ELF to hex/bin using objcopy: riscv32-unknown-elf-objcopy -O binary <elf> <bin> and create big-endian boot.mem as required by TB.
- Memory verification:
    - Use mem_32768x32_tb.sv with mem_init_files; run sim target and consult generated report.

18. Appendix — contacts and collaborators
- Coordinated with: Aditya, Vaibhav, Shrinath, Rakesh and other verification/design/PD team members.
- Points of escalation: design owner for apb_soc_ctrl boot address, PD lead for script errors, tool admin for DPI integrations.

19. Conclusion
My contributions combined verification engineering, firmware/boot image generation, and PD-support activities that materially advanced SIDHARUD1 towards tapeout. I implemented test infrastructure, validated important memories and boot sequences, improved automation, and triaged issues that improved overall design readiness. I remain available to present and defend the work, walk through the TBs and flows, reproduce runs, and implement next recommended steps (DPI integration, flash model upgrade, final RTL fixes) to reach full functional sign-off.

Attachments (available on shared drive):
- TB sources and Makefile (tb_pulp.sv, bootrom TB, mem TB)
- spiflash.v model and usage notes
- Generated boot.mem and example .hex files
- PD script versions and logs (pd_flow_v0/v1/v2)
- Memory verification report and waveform snapshots
- MoM and verification run logs

End of report.
SIDHARUD1 — Individual Contribution Report (Expanded, Detailed)
Author: [Your Name]
Role: Verification engineer (primary); contributor to bootloader development and physical design support
Period: Project duration (5 months) — comprehensive technical record and evidence for evaluation

Table of Contents
1. Cover page
2. Abstract / Executive summary
3. Project context and objectives
4. System architecture and planned modes (detailed)
5. Scope of implemented functionality (Mode-1) and rationale
6. Pin map and pad-level behavior, OE semantics and test implications
7. Verification organization, responsibilities and deliverables
8. Test plan, coverage model and verification strategy
9. Testbench architecture and packages (detailed)
10. Makefile and simulation infrastructure changes (full description)
11. Peripheral models: spiflash substitution and implications
12. Boot ROM and bootloader work: design, generation, validation
13. Firmware toolchain and build flow for RISC‑V images
14. Memory (SRAM) verification: methodology, testcases, results
15. GPIO and I2C (port-extender) verification and firmware integration
16. JTAG, DPI-C integration issues and mitigation approaches
17. Netlist verification, PD-flow contributions and formal checks
18. Automation, regression, release process and tagging
19. Collaboration, communications, MoMs and coordination logs
20. Problem logs and root-cause analyses (rich examples)
21. Reproducibility: commands, scripts, and step-by-step procedures
22. Artifacts produced and their locations (logical listing)
23. Risk, limitations and recommendations for final sign-off
24. Timeline and milestone evidence
25. Skills developed and individual learning outcomes
26. Appendices:
    A. Representative Makefile targets and semantics
    B. Simulation command lines and environment variables
    C. Boot image generation step-by-step with sample commands
    D. Memory test pseudocode and expected outcomes
    E. I2C bootloader instruction set reference (formalized)
    F. PD flow script version differences and common fixes
    G. Sample waveform checklists and debug checklist
    H. Glossary and acronyms

1. Abstract / Executive summary
This expanded report documents, at a granular technical level, the verification, bootloader and physical-design assistance performed during the SIDHARUD1 SoC project. The author served primarily as a verification engineer, later contributing to bootloader development and PD-flow scripting. Deliverables include verification testbenches, memory verification reports, Makefile and simulation infrastructure improvements, a usable open-source SPI flash model integration for functional boot tests, generation of boot images from C sources, and multiple PD script iterations with triage notes. The report contains detailed procedures, testcases, command lines, and rationale to allow replication and assessment by a review panel.

2. Project context and objectives
- Project objective: design, verify, and implement a multi-mode SoC targeted for fabrication in collaboration with foundry and tool vendors. The design aimed to support multiple boot and peripheral modes; resource constraints limited final implementation to a single mode (Mode‑1).
- Academic relevance: integration of digital design (RTL), verification methodology, embedded software (bootloader), PDK cell mapping and PD flows — directly related to VLSI/CAD/embedded systems learning objectives.
- Individual objective: implement robust verification coverage for critical IPs (memories, boot ROM, UART, I2C, GPIO), enable boot testing via available models, and provide PD flow support to clear CDC/netlist issues during pre-tapeout signoff.

3. System architecture and planned modes (detailed)
- Overview of intended four modes with interface permutations (QSPI, SDIO, multiple UARTs and I2C masters/slaves, port-extender topology).
- Mode selection mechanism: BOOT_MODE_SEL pin and configuration registers; JTAGEN field selects JTAG vs FGPIO behavior for relevant pins.
- Mode-1 chosen for implementation: JTAG enabled by default, QSPI flash boot method prioritized, I2C and UART available as per area constraints.

4. Scope of implemented functionality (Mode-1) and rationale
- Due to area and schedule constraints, verification and integration prioritized the most critical runtime boot and debug modes. Mode-1 contains the boot path, general-purpose IO, I2C, UART and JTAG infrastructures required for initial board bring-up and firmware development.
- Verification priorities mapped to risk and impact: memories and boot ROM first, then boot-from-flash path, then peripherals needed by bootloader (I2C, GPIO), then debugging interfaces (JTAG).

5. Pin map, pad-level behavior and test implications
- Detailed pad mapping for Mode-1 including input pins (CLK, RST_N, TCK/TMS/TDI/TRST as conditional FGPIO), FGPIO_IN_X pin list, I2C_S_SCL_I and I2C_S_SDA, and outputs including TDO and FGPIO_OUT_X pins.
- Pad-level characteristics and verification implications:
    - Directionality checks: simulation testbenches validated that top-level instantiation reflects correct input/output/bi-direction behaviors.
    - Tri-state/OE semantics: OE behavior tested by toggling OE in simulation where available; pads that map to open-drain required specific firmware/testbench interactions.
    - Boot selection and triaging: test cases created to drive BOOT_MODE_SEL and observe the processor vectoring behavior.
- Test vectors for pad-level checks (sentences converted to actionable sequences): examples include writing/reading pad configuration registers, validating that inputs reflect stimulus, validating that outputs tri-state when disabled.

6. Verification organization, responsibilities and deliverables
- Role breakdown and individual accountability:
    - Test planning and documentation: MoMs, verification matrix, testcases, and artifact repository maintenance.
    - TB development and package maintenance: creation / modification of system-level TB files and packages required for compilation.
    - Peripheral verification: I2C functional checks for port-extender behavior, GPIO loopback, UART smoke tests.
    - Memory verification: unit verification of large SRAM macros and FIFO memories with directed and randomized tests.
    - Firmware/build: integration with the RISC‑V toolchain to produce boot images and hex/bin conversions.
    - PD support: modifying and testing PD scripts, running netlist checks, and using formality when possible.
- Primary deliverables:
    - Testbenches (bootrom TB, mem TB), spiflash integration, Makefile targets, memory init files, PD script versions and logs, and verification reports.

7. Test plan, coverage model and verification strategy
- Top-level verification plan: component-level unit tests progressing to system-level smoke tests with boot-from-flash, then directed stress tests.
- Coverage model:
    - Functional coverage points defined for memory operations (R/W patterns, byte-enable combos), boot sequences (correct entry address, instruction fetch sequences, correct peripheral init), and peripheral command-response coverage for I2C bootloader commands.
    - Toggle/statement coverage: maintain clean simulation without extraneous warnings to ensure meaningful coverage metrics.
- Regression strategy:
    - Local development regressions for quick iterations.
    - Consolidated regression runs with canonical test inputs and automated reporting.
    - Target makefile commands for nightly or CI runs (documented in Appendix A).

8. Testbench architecture and packages (detailed)
- tb_pulp.sv chosen as top-level TB; architecture decomposition:
    - Clock/reset generator module
    - JTAG VIP and TAP wrapper
    - SPI flash model hooking into external memory interface
    - I2C VIP for port-extender emulation
    - UART RX/TX VIP harness
    - Boot ROM loader and testbench control bus for initializing memory images
- Packages added/used:
    - riscv_pkg and pulp-specific packages for instruction definitions, endianness assumptions and helper tasks.
- Instantiation notes:
    - The DUT (core-v-mcu) integration required careful mapping of clock nets to submodules. Missing submodule clock connections were identified and recorded; testbench wrappers were created to explicitly route clock and reset to sub-elements for functional simulation.
- Internal TB utilities:
    - Memory loader tasks: load_mem_hex(), read_mem_word()
    - Debug print tasks: tb_printf_addr_word()
    - Synchronization tasks: wait_for_response(), wait_for_ready()

9. Makefile and simulation infrastructure changes (full description)
- Major Makefile modifications and rationale:
    - Added compile targets for tb_pulp.sv and dependent packages with a consistent order to avoid missing package errors.
    - Added MAKE targets:
        - compile_tb: compiles TB + DUT
        - sim_tb: runs simulation for a selected TARGET (e.g., TARGET=bootrom)
        - run_verdi: launches Verdi with correct file lists and dump files
        - run_vcs: canonical vcs/vcs+ compile and link lines with +define+ flags and simulation options
    - Verdi integration: added dedicated target to invoke Verdi with the proprietary arguments needed by the lab, and a helper script to collect simulation dumps into the shared drive location.
- Key environment settings documented:
    - VCS_HOME, VERDI_HOME, SIM_LIB_PATH, PDK_LIBS
    - SPDX/code-signature notes for proprietary models (handled per license)
- Build reproducibility:
    - Added explicit include lists and canonical file ordering.
    - Introduced a small harness script (ci_sim.sh) to set environment variables and call make with consistent options for automation.

10. Peripheral models: spiflash substitution and implications
- Problem statement: s25fe256s flash model proprietary; restricted integration and distribution.
- Action taken: integrated open-source spyflash.v as a practical alternative to permit boot-from-flash functional tests.
- Integration steps:
    - Adapted spyflash.v interface signals to DUT spim pins.
    - Created a wrapper to feed binary image (boot.mem) into the spyflash model before simulation start.
    - Documented limitations: timing and behavior differences from vendor model; suitable for validating functional fetch sequences but not for signoff timing closure.
- Testcases executed:
    - Flash read command sequences and boot image loads.
    - Negative tests for corrupt flash image and verifying boot ROM behavior on failed fetch.

11. Boot ROM and bootloader work: design, generation, validation
- Boot ROM responsibilities:
    - Determine boot source (SPI flash, JTAG), initialize peripherals required for loading (SPIM, UART, I2C), copy image into L2 or RAM and jump to entry point.
- Boot ROM verification tasks:
    - Created dedicated bootrom testbench to validate hex content, address mapping, and readback procedures.
    - Validated endianness: determined that the SOC expected 32-bit words in Big-Endian order for final ROM load method and ensured objcopy conversions respected that.
    - Performed readback tests to ensure contents loaded correctly into simulated memory via the testbench loader and/or spyflash model.
- Bootloader instruction set (I2C-based) verification:
    - Formalized the command/response encoding for the I2C-based loader (command opcodes, argument lengths, success/fail codes).
    - Wrote assembly examples that exercise each command and validated responses via testbench-driven I2C stimulus.
- Issues discovered and actions:
    - Missing apb_soc_ctrl -> boot_rom connection. Logged and coordinated proposed change to default boot address from 0x1A000080 to 0x1A000000 to reflect actual ROM mapping;recommendation documented with a patch suggestion and impact analysis.
    - Identified unconnected pin in mem.slave interface (r_opc). Tracked resolution steps and suggested RTL fixes.

12. Firmware toolchain and build flow for RISC‑V images
- Tools used: riscv32-unknown-elf-gcc, riscv32-unknown-elf-objcopy, riscv32-unknown-elf-objdump.
- Build pipeline:
    - Cross-compile C sources to ELF: riscv32-unknown-elf-gcc -march=rv32im -mabi=ilp32 -O2 -nostdlib -T linker_script.ld -o main.elf main.c spi.c bootcode.c
    - Produce binary: riscv32-unknown-elf-objcopy -O binary main.elf main.bin
    - Produce hex/boot.mem: custom script to split binary into 32-bit words and format in big-endian for bootrom loader (detailed sample command in Appendix C).
- Problems encountered:
    - Missing header files and config artifacts produced by external installation scripts (install-core-v-mcu); resolved via coordination with software team and selective extraction of generated config headers.
    - Errors in build due to assembler/target mismatch; resolved by freezing toolchain version and explicit compiler flags.
- Example of workflow steps used to debug:
    - Use objdump -D main.elf to visually verify instruction word encodings and ensure expected opcodes are present.
    - Use small bootloader test programs to toggle GPIO and verify via testbench reads.

13. Memory (SRAM) verification: methodology, testcases, results
- Memory library and mapping:
    - Major memories: core_v_mcu_interleaved_ram_* (32768x32), private RAMs, boot ROM (2048x32), debug ROM and multiple FIFO/queue memories.
    - PDK mapping: selected gf180mcu_fd_ip_sram macros mapped per width and depth with required instance counts based on physical tiling strategy; verified instance counts against RTL expectations.
- Unit memory verification approach:
    - Directed tests to validate read-after-write, byte-enable semantics, reset behavior, chip enable behavior, and global write enable semantics.
    - Randomized stress tests (PRNG seeded) covering a broad address range and varied byte-enable patterns.
    - Edge-case tests for boundary addresses, wrap-around behaviors, and concurrency when supported by multiport variants.
- Testcases executed (for 32768x32):
    - RESET TEST: verify initial contents as specified by mem_init_files or all zeros when uninitialized.
    - Initialization WRITE/READ: write deterministic patterns across entire address range, then read back and compare.
    - WRITE - Random Address Locations: N random writes and immediate reads to validate atomic behavior.
    - READ at written locations: read after writes ensure proper data retention.
    - BYTE ENABLE TEST: write with various WEN masks to verify individual byte lanes write correctly.
    - MEMORY_DISABLE TEST: gate reads/writes with CEN toggles and ensure bus is inert when disabled.
    - CHIP_EN and GWEN combined tests.
- Tools and methods:
    - Memory verification harness mem_32768x32_tb.sv created with test vectors, logging, and failure counters.
    - Waveform triage: specific failure cycles captured using VCD/FSDB and analyzed to find timing/behavioral mismatches; snapshots stored in the shared drive.
- Results summary:
    - Standalone memory passed the specified test suite after adjustments in initialization files and minor timing alignment in TB (added guard delays).
    - Reorganized mem_init_files folder and created a canonical set used by all TBs to ensure consistent regression results.
- A concrete example of a failing case and root-cause:
    - Symptom: intermittent read glitch on random-read test causing incorrect data for a single bus cycle.
    - Root cause: TB assumed combinational read behavior; the PDK cell model exhibited registered outputs with an extra cycle latency when CEN toggled rapidly.
    - Fix: TB updated to respect cell timing and inserted small delays before sampling; regression passed.

14. GPIO and I2C (port-extender) verification and firmware integration
- Objectives:
    - Verify that GPIOs can be toggled, read back, and that direction and OE semantics function correctly.
    - Validate I2C master and slave behavior for port-extender functionality, including the I2C-based bootloader command/response sequence.
- Approach:
    - Created firmware_for_verification.txt with assembly sequences that exercise GPIO read/write and I2C commands.
    - Used TB-driven I2C stimuli and a small model of a port-extender device to emulate external I2C behavior.
    - Verified loopback tests for GPIO by wiring outputs to inputs in the TB for selected pins and running firmware that writes patterns and reads them back.
- Issues and fixes:
    - Missing pin connections for some pins resolved by instantiating explicit pin-nets in testbench and mapping them to DUT top-level ports.
    - Warnings during RTL+TB compilation were systematically removed; fixed by adding missing packages or correcting package import order.
- Outcome:
    - I2C-based port-extender behavior validated; assembly snippets provided that can be used to program external test sequences.

15. JTAG, DPI-C integration issues and mitigation approaches
- Observations:
    - JTAG signals present in TB (TCK/TMS/TDI/TDO). However, automated JTAG loading and binary transfer centrally require a DPI-C component (e.g., jtag_dpi.c).
    - No DPI-C module was present in the current repo, preventing end-to-end DPI-based JTAG boot automation.
- Actions taken:
    - Documented the expected DPI responsibilities: drive TCK/TMS/TDI, capture TDO, load program binaries into memory via scan chains or debug module, and trigger CPU start.
    - Proposed alternatives:
        - Add or restore DPI-C jtag_dpi.c from vendor or internal repository and integrate with TB.
        - Use spyflash.v based boot approach as a pragmatic alternative for initial verification until DPI is available.
- Mitigation tests:
    - Verified manual JTAG flow by toggling registers and simulating how a DPI would perform loading steps; used TB-level tasks to emulate DPI-driven writes where DPI is absent.

16. Netlist verification, PD-flow contributions and formal checks
- PD flows developed: pd_flow_v0, pd_flow_v1, pd_flow_v2 created iteratively to run place-and-route steps, signoff checks and timing/power analyses.
- Responsibilities:
    - Implemented and tested PD-flow scripts, captured errors and warnings (floorplanning issues, pin naming mismatches, missing power nets).
    - Provided fixes or clear issue reports to PD/design leads; in many cases corrected script bugs directly (path corrections, parameter adjustments).
- Netlist verification:
    - RTL-to-netlist comparison procedures performed via structural checks and by invoking formality where applicable.
    - Cross-checked cell mapping for SRAM macros and counted instances row/column-wise to verify correct tiling and memory organization.
- Example common issues and fixes:
    - Mis-specified net names resulting from different naming conventions between synthesis tool and PD scripts — fixed by consistent renaming at synthesis stage or PD wrapper layers.
    - Missing VSS/VDD power pins on certain lower-level IP macros in netlist requiring wrapper instantiation adjustments.

17. Automation, regression, release process and tagging
- Created a canonical process for verification tag release:
    - Run full suite locally and in CI (where available).
    - Produce a verification summary report with pass/fail counts and waveforms for failures.
- Released verification tag after meeting the acceptance criteria:
    - Memory verification passed,
    - Boot ROM and basic boot-from-spi sequence validated,
    - Peripheral smoke tests passed,
    - Clean TB compilation (no warnings deemed relevant).
- Automation artifacts:
    - ci_sim.sh: wrapper to run a set of canonical targets and produce a short summary output for tracking.
    - A report generator that scans simulation logs for PASS/FAIL and assembles a short HTML/text dashboard in the shared drive.

18. Collaboration, communications, MoMs and coordination logs
- Maintained meeting minutes (MoM) and progress logs covering:
    - Daily/weekly verification standups,
    - Inter-team coordination with design, software, and PD teams,
    - Email threads to escalate missing components (e.g., DPI-C model) or request design changes (boot address).
- Example coordination items:
    - Raised the boot address mismatch and proposed change after discussion and local verification; recorded impact assessment and timeline for review.
    - Shared memory verification results and waveform snapshots with design owner for further debugging.

19. Problem logs and root-cause analyses (rich examples)
- Each encountered issue documented with:
    - Symptom,
    - Testcase and reproduction steps,
    - Root-cause analysis,
    - Corrective actions and verification of fix.
- Representative issues:
    1) Missing DPI-C jtag_dpi.c — blocked JTAG boot; mitigated using spyflash.v and documented DPI requirements.
    2) Wrong boot_rom default address in apb_soc_ctrl — documented proposed change and requested design review.
    3) Memory read glitch due to timing assumption — fixed in TB by respecting cell output latency.
    4) Missing DUT clock routing in TB — top-level instantiation corrected and small wrapper added to ensure all submodules receive external CLK.

20. Reproducibility: commands, scripts, and step-by-step procedures
- Simulation compile example:
    - make compile_tb SIM_TOOL=vcs TOP=tb_pulp
    - make sim_tb TARGET=bootrom SIM_TOOL=vcs RUN_OPTIONS="+vcs+lic+wait"
- Launch Verdi example:
    - make run_verdi TOP=tb_pulp VERDI_ARGS="-ssf dump.ssf -vcd dump.vcd"
- Boot image generation (high-level):
    - riscv32-unknown-elf-gcc -march=rv32im -mabi=ilp32 -nostdlib -Tlinker.ld -o main.elf main.c
    - riscv32-unknown-elf-objcopy -O binary main.elf main.bin
    - python3 scripts/bin_to_big_endian_mem.py main.bin > boot.mem
- Memory verification run:
    - make sim_tb TARGET=mem32768x32 LOG=mem_test.log
    - Analyze results via parse_mem_log.py which produces a pass/fail matrix and generates the waveform snapshot if a failure occurs.

21. Artifacts produced and their locations (logical listing)
- Testbenches: tb_pulp.sv, bootrom_tb.sv, mem_32768x32_tb.sv
- Simulation harness scripts: ci_sim.sh, run_verdi.sh
- Makefile changes: top-level Makefile additions and targets under verification/
- Boot images: boot.bin, boot.mem and associated .elf files saved in shared drive under /images/
- PD scripts: pd_flow_v0, pd_flow_v1, pd_flow_v2 and corresponding logs stored under /pd/
- Temporary models: spiflash.v wrapper and integration notes under /models/
- Documentation: MoMs, verification summary, memory verification report, and waveform snapshots under /reports/

22. Risk, limitations and recommended actions
- Risks and current limitations:
    - DPI-C JTAG absent: prevents full automated JTAG-based boot testing; recommend restore or recreate DPI component.
    - Proxy flash model used (spyflash.v) may not capture vendor-specific behaviors critical for final signoff. Recommend: obtain vendor model or augment the open model to match critical behaviors.
    - Some top-level pin connections and boot address mismatches remain open and require design changes for final signoff.
- Recommendations:
    - Integrate DPI-C JTAG model into repository and ensure license compliance.
    - Align apb_soc_ctrl boot vector with boot ROM mapping if agreed by design owners.
    - Run full-system regression with vendor flash model once licensing is cleared.
    - Expand regression coverage for peripheral stress tests and edge-case boot scenarios.

23. Timeline and milestone evidence (detailed)
- 25/05/2025 — Verified basic .c → binary flow for reading into memory.
- 27/05/2025 — Boot ROM content verified with TB loader; initial hex files generation validated.
- 16/06/2025 — Clean compilation of TB with DUT instantiation and required packages (warnings minimized).
- 25/06/2025 — Standalone memory (32768x32) verification completed successfully.
- 28/06/2025 — First custom bootcode flashed into emulator via spiflash.v and basic boot validated.
- 03/07/2025 — GPIO verification completed with loopback tests and firmware-driven validation.
- 11/07/2025 — I2C design updates validated and firmware integration confirmed.
- 01/08/2025 — Additional SRAM variants verified and automation framework matured to support single-command runs.
- 04/08/2025 — Automation: created summary output and run scripts enabling consolidated runs.

24. Skills developed and individual learning outcomes
- Applied verification methodologies and testbench architecture.
- Gained practical experience with RISC‑V cross toolchain for embedded images.
- Hands-on mapping and validation of PDK SRAM cells and PD flow integration.
- Increased familiarity with simulation flows (VCS, Verdi), waveform analysis and formal equivalence techniques.
- Practiced cross-team coordination: clarifying design expectations, proposing RTL changes and triaging PD errors.

25. Appendices (selected highlights and commands)

Appendix A — Representative Makefile targets (semantics)
- compile_tb: compile order = packages -> vip -> rtl -> tb
- sim_tb: runs simulation with specified TARGET, collects log
- run_verdi: launches Verdi with last run's dump files

Appendix B — Simulation command lines
- VCS compile example:
    vcs -full64 -sverilog +v2k +incdir+./tb +lint=none -f file_list.f -o simv
- VCS run:
    ./simv +UVM_TESTNAME=test_boot -l sim.log

Appendix C — Boot image generation step-by-step
1) Compile:
    riscv32-unknown-elf-gcc -march=rv32im -mabi=ilp32 -O2 -c -o boot.o boot.c
2) Link:
    riscv32-unknown-elf-ld -T boot.ld -o boot.elf boot.o
3) Binary:
    riscv32-unknown-elf-objcopy -O binary boot.elf boot.bin
4) Convert to big-endian 32-bit words (example script or objcopy with endianness handling):
    python3 scripts/bin2be_mem.py boot.bin > boot.mem

Appendix D — Memory test pseudocode (core 32768x32)
- For address in 0..32767:
    write(address, pattern = addr ^ 0xA5A5A5A5)
- For address in 0..32767:
    read_data = read(address)
    assert read_data == pattern
- Byte enable tests: for each byte-lane combination set WEN accordingly and verify only targeted bytes updated.

Appendix E — I2C bootloader instruction set (formalized)
- Command packet format (Master->Slave):
    - Byte0: OPCODE
    - Byte1..N: Arguments (length depends on opcode)
- Key opcodes:
    - 0x01 load_instruction: payload = [N][N*4 bytes]
    - 0x02 jump_to_ram: no payload
    - 0x03 immediate_execute: 4-byte single instruction payload
- Response codes:
    - 0xAB ACK for load
    - 0xA2 ACK for jump_to_ram
    - 0xE0 invalid opcode

Appendix F — PD flow versions (high-level differences)
- pd_flow_v0: prototype with basic place/route steps, minimal checking.
- pd_flow_v1: added power-net tuning and wrapper insertion automation.
- pd_flow_v2: error handling, pin renaming automation, and log parsing for automated triage.

Appendix G — Waveform and debug checklist
- Ensure clocks show expected frequency and duty-cycle
- Check reset deassertion timing relative to first fetch
- Validate address bus values when reading from boot ROM
- Check QSPI MISO/MOSI transactions during boot
- Trace CPU program counter and ensure expected instruction sequence

Appendix H — Glossary and acronyms
- DUT: Device Under Test
- TB: Testbench
- PD: Physical Design
- PDK: Process Design Kit
- DPI-C: Direct Programming Interface for C (used to integrate C models with SystemVerilog)
- QSPI: Quad SPI
- JTAG: Joint Test Action Group (debug/test interface)

26. Conclusion
This document expands the earlier summary into an operational, step-by-step technical dossier suitable for individual evaluation and viva. It preserves traceability between objectives, actions, and results; lists artifacts and reproduction steps; and contains detailed records of the verification, firmware and PD-support work carried out. The author is prepared to present, demonstrate the testbench runs and waveforms, reproduce the boot image generation workflow, and provide live walkthroughs of the memory verification regressions and PD-flow scripts.

Attachments and supplementary materials (available on the shared drive):
- All testbenches and scripts referenced above
- Generated binaries and boot.mem images
- Waveform snapshots (VCD/FSDB) and Verdi session files
- PD flow logs and netlist verification reports
- MoM and run logs

End of report.